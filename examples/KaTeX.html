<!DOCTYPE html>
<meta charset="UTF-8">
<html>
  <head>
    <!-- KaTeX specific code START --> 
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.css" integrity="sha384-SkMvsJ0Np/CalM0X1hZCccQs6tnLq178/sGoPANiauambU0V/bloCaG3wOXfv+Ef" crossorigin="anonymous">
    <!-- KaTeX specific code END --> 
    <script type="module" type="text/javascript">
        // KaTeX specific code START
        import katex from 'https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.mjs';
        // KaTeX specific code END
        import * as mke from '../../dist/MathKeyboardEngine.es2020-esm.js';
        let latexConfiguration = new mke.LatexConfiguration();
        let keyboardMemory = new mke.KeyboardMemory();

        displayEditModeLatex();

        registerNodeKey('infinity', mke.Insert, () => new mke.RawNode(String.raw`\infty `));
        registerNodeKey('leftarrow', mke.Insert, () => new mke.RawNode(String.raw`\leftarrow `));
        registerNodeKey('rightarrow', mke.Insert, () => new mke.RawNode(String.raw`\rightarrow `));
        registerNodeKey('uparrow', mke.Insert, () => new mke.RawNode('\\uparrow '));
        registerNodeKey('downarrow', mke.Insert, () => new mke.RawNode(String.raw`\downarrow `));

        for (let i = 0; i < 10; i++) {
          registerNodeKey('digit' + i, mke.Insert, () => new mke.DigitNode(i.toString()));
        }

        for(let letter of ['a', 'b', 'c', 'x', 'y', 'z']){
          registerNodeKey(letter, mke.Insert, () => new mke.RawNode(letter));
        }

        for(let afterslash of ['alpha', 'beta', 'gamma', 'lambda', 'mu', 'pi', 'div', 'sin', 'tan', 'cos', 'arcsin', 'arccos', 'arctan']){
          registerNodeKey(afterslash, mke.Insert, () => new mke.RawNode('\\' + afterslash + ' '));
        }

        registerNodeKey('decimalSeparator', mke.Insert, () => new mke.DecimalSeparatorNode())

        registerNodeKey('approx', mke.Insert, () => new mke.RawNode(String.raw`\approx `));
        registerNodeKey('equal', mke.Insert, () => new mke.RawNode('='));
        registerNodeKey('notEqual', mke.Insert, () => new mke.RawNode(String.raw`\neq `));

        registerNodeKey('lessThan', mke.Insert, () => new mke.RawNode('<'));
        registerNodeKey('greaterThan', mke.Insert, () => new mke.RawNode('>'));
        registerNodeKey('lessThanOrEqual', mke.Insert, () => new mke.RawNode(String.raw`\leq `));
        registerNodeKey('greaterThanOrEqual', mke.Insert, () => new mke.RawNode(String.raw`\geq `));

        registerNodeKey('plus', mke.Insert, () => new mke.RawNode('+'));
        registerNodeKey('minus', mke.Insert, () => new mke.RawNode('-'));
        registerNodeKey('times', mke.Insert, () => new mke.RawNode(String.raw`\times `));
        registerNodeKey('ratio', mke.Insert, () => new mke.RawNode(':'));
        registerNodeKey('faculty', mke.Insert, () => new mke.RawNode('!'));

        registerNodeKey('fraction', mke.Insert, () => new mke.MultiplePlaceholdersDescendingRawNode(String.raw`\frac{`, '}{', '}'));
        registerNodeKey('binomial', mke.Insert, () => new mke.MultiplePlaceholdersDescendingRawNode(String.raw`\binom{`, '}{', '}'));

        registerNodeKey('power', (k, powerNode) => {
          if (!mke.TryInsertWithEncapsulateCurrent(k, powerNode)){
            mke.Insert(k, powerNode);
          }
        }, () => new mke.MultiplePlaceholdersAscendingRawNode('', '^{', '}'));
        registerNodeKey('subscript', (k, subscriptNode) => {
          if (!mke.TryInsertWithEncapsulateCurrent(k, subscriptNode)){
            mke.Insert(k, subscriptNode);
          }
        }, () => new mke.MultiplePlaceholdersDescendingRawNode('', '_{', '}'));
        registerNodeKey('squareRoot', mke.Insert, () => new mke.SinglePlaceholderRawNode(String.raw`\sqrt{`, '}'));
        registerNodeKey('nthRoot', mke.Insert, () => new mke.MultiplePlaceholdersDescendingRawNode(String.raw`\sqrt[`, ']{', '}'));

        registerNodeKey('roundBrackets', mke.Insert, () => new mke.RoundBracketsNode());
        registerNodeKey('squareBrackets', mke.Insert, () => new mke.SinglePlaceholderRawNode(String.raw`\left[`, String.raw`\right]`));
        registerNodeKey('pipes', mke.Insert, () => new mke.SinglePlaceholderRawNode(String.raw`\left|`, String.raw`\right|`));
        registerNodeKey('doublePipes', mke.Insert, () => new mke.SinglePlaceholderRawNode(String.raw`\left\|`, String.raw`\right\|`));
        registerNodeKey('curlyBrackets', mke.Insert, () => new mke.SinglePlaceholderRawNode(String.raw`\left\{`, String.raw`\right\}`));

        registerNodeKey('naturalNumbers', mke.Insert, () => new mke.RawNode(String.raw`\mathbb{N}`));
        registerNodeKey('integers', mke.Insert, () => new mke.RawNode(String.raw`\mathbb{Z}`));
        registerNodeKey('realNumbers', mke.Insert, () => new mke.RawNode(String.raw`\mathbb{R}`));

        registerNodeKey('isMemberOf', mke.Insert, () => new mke.RawNode(String.raw`\in `));
        registerNodeKey('isProperSubsetOf', mke.Insert, () => new mke.RawNode(String.raw`\subset `));
        registerNodeKey('isSubsetOf', mke.Insert, () => new mke.RawNode(String.raw`\subseteq `));
        registerNodeKey('setDifference', mke.Insert, () => new mke.RawNode(String.raw`\setminus `));
        registerNodeKey('exists', mke.Insert, () => new mke.RawNode(String.raw`\exists `));
        registerNodeKey('existsOne', mke.Insert, () => new mke.RawNode(String.raw`\exists! `));
        registerNodeKey('forAll', mke.Insert, () => new mke.RawNode(String.raw`\forall `));
        registerNodeKey('not', mke.Insert, () => new mke.RawNode(String.raw`\neg `));
        registerNodeKey('or', mke.Insert, () => new mke.RawNode(String.raw`\lor `));
        registerNodeKey('and', mke.Insert, () => new mke.RawNode(String.raw`\land `));
        registerNodeKey('doubleRightArrow', mke.Insert, () => new mke.RawNode(String.raw`\Rightarrow `));
        registerNodeKey('doubleLeftArrow', mke.Insert, () => new mke.RawNode(String.raw`\Leftarrow `));

        registerNodeKey('sin-1', mke.Insert, () => new mke.RawNode(String.raw`\sin^{-1}`));
        registerNodeKey('cos-1', mke.Insert, () => new mke.RawNode(String.raw`\cos^{-1}`));
        registerNodeKey('tan-1', mke.Insert, () => new mke.RawNode(String.raw`\tan^{-1}`));
        registerNodeKey('sininv', mke.Insert, () => new mke.RawNode(String.raw`\sin^{inv}`));
        registerNodeKey('cosinv', mke.Insert, () => new mke.RawNode(String.raw`\cos^{inv}`));
        registerNodeKey('taninv', mke.Insert, () => new mke.RawNode(String.raw`\tan^{inv}`));

        registerNodeKey('integral', mke.Insert, () => new mke.MultiplePlaceholdersAscendingRawNode(String.raw`\int_{`, '}^{', '}'));
        registerNodeKey('sum', mke.Insert, () => new mke.MultiplePlaceholdersAscendingRawNode(String.raw`\sum_{`, '}^{', '}'));
        registerNodeKey('product', mke.Insert, () => new mke.MultiplePlaceholdersAscendingRawNode(String.raw`\prod_{`, '}^{', '}'));
        registerNodeKey('limit', mke.Insert, () => new mke.SinglePlaceholderRawNode(String.raw`\lim_{`, '}'));

        const matrixWidthInputElement = document.getElementById('matrixWidth');
        const matrixHeightInputElement = document.getElementById('matrixHeight');
        function ReRegisterMatrix() {
          registerNodeKey('pmatrix', mke.Insert, () => new mke.MatrixNode({
            matrixType:'pmatrix', 
            width: matrixWidthInputElement.value, 
            height: matrixHeightInputElement.value
          }));
          registerNodeKey('vmatrix', mke.Insert, () => new mke.MatrixNode({
            matrixType:'vmatrix', 
            width: matrixWidthInputElement.value, 
            height: matrixHeightInputElement.value
          }));
        }
        ReRegisterMatrix();
        matrixWidthInputElement.onclick = ReRegisterMatrix;
        matrixHeightInputElement.onclick = ReRegisterMatrix;

        registerKey('moveLeft', mke.MoveLeft);
        registerKey('moveRight', mke.MoveRight);
        registerKey('moveUp', mke.MoveUp);
        registerKey('moveDown', mke.MoveDown);

        registerKey('deleteCurrent', mke.DeleteCurrent);

        function registerNodeKey(elementId, onclickArrowFuncForKeyboardMemoryAndNode, nodeGetter) {
          let element = document.getElementById(elementId);
          let latex = mke.GetViewModeLatex(nodeGetter(), latexConfiguration);
          renderLatexInKey(latex, element);
          element.onclick = () => {
            onclickArrowFuncForKeyboardMemoryAndNode(keyboardMemory, nodeGetter());
            displayEditModeLatex();
          };
        }

        function registerKey(elementId, onclickArrowFuncForKeyboardMemory){
          let element = document.getElementById(elementId);
          element.onclick = () => {
            onclickArrowFuncForKeyboardMemory(keyboardMemory);
            displayEditModeLatex();
          };
        }

        function displayEditModeLatex(){
          let latex = mke.GetEditModeLatex(keyboardMemory, latexConfiguration);
          let element = document.getElementById('output');
          renderLatexInOutputBox(latex, element);
        }

        // === KaTeX specific code START ===
        function renderLatexInKey(latex, element) {
          katex.render(latex, element, { throwOnError: false });
        }

        function renderLatexInOutputBox(latex, element) {
          katex.render(latex, element, { displayMode: true, throwOnError: false });
        }
        // === KaTeX specific code END ===
    </script>
    <style>
      #output{
        border: 1px solid gray;
        padding: 5px;
      }
      #mathKeyboard > * {
        display: inline-block;
        vertical-align: top;
        border: 1px solid gray;
        padding: 5px;
        margin: 2px;
      }

      .arrow-up {
        width: 0; 
        height: 0; 
        border-left: 10px solid transparent;
        border-right: 10px solid transparent;
        border-bottom: 10px solid black;
      }
      .arrow-down {
        width: 0; 
        height: 0; 
        border-left: 10px solid transparent;
        border-right: 10px solid transparent;
        border-top: 10px solid black;
      }
      .arrow-right {
        width: 0; 
        height: 0; 
        border-top: 10px solid transparent;
        border-bottom: 10px solid transparent;
        border-left: 10px solid black;
      }
      .arrow-left {
        width: 0; 
        height: 0; 
        border-top: 10px solid transparent;
        border-bottom: 10px solid transparent;
        border-right: 10px solid black;
      }
    </style>
  </head>
<body>
<h1>MathKeyboardEngine + KaTeX</h1>
<h3>Example keys - to be styled - to help you design your keyboard</h3>
<div id="output"></div>
<br/>
<div id="mathKeyboard">
  <div><div id="moveLeft" class="arrow-left"></div></div>
  <div><div id="moveRight" class="arrow-right"></div></div>
  <div><div id="moveDown" class="arrow-down"></div></div>
  <div><div id="moveUp" class="arrow-up"></div></div>
  <div id="deleteCurrent">&#128293;</div>
  <br/>
  <div id="digit0"></div>
  <div id="digit1"></div>
  <div id="digit2"></div>
  <div id="digit3"></div>
  <div id="digit4"></div>
  <div id="digit5"></div>
  <div id="digit6"></div>
  <div id="digit7"></div>
  <div id="digit8"></div>
  <div id="digit9"></div>
  <div id="decimalSeparator"></div>
  <br/>
  <div id="a"></div>
  <div id="b"></div>
  <div id="c"></div>
  <div id="x"></div>
  <div id="y"></div>
  <div id="z"></div>
  <div id="alpha"></div>
  <div id="beta"></div>
  <div id="gamma"></div>
  <div id="lambda"></div>
  <div id="mu"></div>
  <div id="pi"></div>
  <br>
  <div id="plus"></div>
  <div id="minus"></div>
  <div id="times"></div>
  <div id="ratio"></div>
  <div id="div"></div>
  <div id="faculty"></div>
  <br/>
  <div id="binomial"></div>
  <div id="fraction"></div>
  <div id="power"></div>
  <div id="subscript"></div>
  <div id="squareRoot"></div>
  <div id="nthRoot"></div>
  <br/>
  <div id="roundBrackets"></div>
  <div id="squareBrackets"></div>
  <div id="curlyBrackets"></div>
  <div id="pipes"></div>
  <div id="doublePipes"></div>
  <br>
  <div style="text-align: right;">
    <label for="matrixHeight">Height</label>
    <input id="matrixHeight" type="number" value='2' min='1' style="width:50px" />
    <br/>
    <label for="matrixWidth">Width</label>
    <input id="matrixWidth" type="number" value='2' min='1' style="width:50px" />
  </div>
  <div id="pmatrix"></div>
  <div id="vmatrix"></div>
  <br>
  <div id="approx"></div>
  <div id="equal"></div>
  <div id="notEqual"></div>
  <div id="lessThanOrEqual"></div>
  <div id="greaterThanOrEqual"></div>
  <div id="lessThan"></div>
  <div id="greaterThan"></div>
  <br/>
  <div id="naturalNumbers"></div>
  <div id="integers"></div>
  <div id="realNumbers"></div>

  <div id="isMemberOf"></div>
  <div id="isProperSubsetOf"></div>
  <div id="isSubsetOf"></div>
  <div id="setDifference"></div>
  <div id="exists"></div>
  <div id="existsOne"></div>
  <div id="forAll"></div>
  <div id="not"></div>
  <div id="or"></div>
  <div id="and"></div>
  <div id="doubleRightArrow"></div>
  <div id="doubleLeftArrow"></div>
  <br/>
  <div id="sin"></div>
  <div id="cos"></div>
  <div id="tan"></div>
  <div id="arcsin"></div>
  <div id="arccos"></div>
  <div id="arctan"></div>
  <div id="sin-1"></div>
  <div id="cos-1"></div>  
  <div id="tan-1"></div>
  <div id="sininv"></div>
  <div id="cosinv"></div>
  <div id="taninv"></div>
  <br/>
  <div id="integral"></div>
  <div id="sum"></div>  
  <div id="product"></div>
  <div id="limit"></div>
  <div id="leftarrow"></div>
  <div id="rightarrow"></div>
  <div id="uparrow"></div>
  <div id="downarrow"></div>
  <div id="infinity"></div>
</div>
</body>
</html> 